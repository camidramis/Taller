import math as mt
#import numpy as np
#import matplotlib.pyplot as plt


def derivadabis(t,g,h,metodo):
    if metodo == 'centrada':
        der=(g(t+h)-g(t-h))/(2*h)
    else: 
        der((g(t+h)-g(t))/h)
    return der

def func1(t):
    return(t**2)

def func2(t):
    return t**2 - 1

def func3(t):
    return (mt.sin(t))-t


#Clase 6: BILLAR ELIPTICO

#Función elíptica
def elip_func(a,b,x):
    return x[0]**2/a**2+x[1]**2/b**2

def recta(pos,t,v):
    vt=tuple(t*i for i in v)
    x1=pos[0]+vt[0]
    y1=pos[1]+vt[1]
    return(x1,y1)

def comp(t):
    return(elip_func(a1,b1,recta(pos,t,vec)))


#Metodo de newton
def metNewton(xi,f,kmax,ep):
    if derivadabis(xi,f,0.001,'centrada')!=0:
        k=0
        xf=xi
        while k<kmax:
            #x=xf
            xf=xf-f(xi)/derivadabis(xi,f,0.00001,'centrada')
            k=k+1
            if f(xf)<ep:
                return xf, k

ep_pred=0.01
#m,n=metNewton(3,func1,50,ep_pred)
#func1(m) #da un numero muy cercano a 0
#metNewton(2,func2,50,ep_pred)

pos=(1,2)
vec=(3/5,4/5)

a1=mt.sqrt(2)
b1=mt.sqrt(2)

r1=recta(pos,5,vec)
elip_func(a1,b1,r1)

t_estrella, k = metNewton(t,comp,50,ep_pred)

#Tengo que buscar el punto de impacto evaluando t* en la recta. 
punto_impacto=recta(pos,t_estrella,vec)

#Verifico
elip_func(a1,b1,punto_impacto)

#Raaaro
