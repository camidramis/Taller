import math as mt
#import numpy as np
#import matplotlib.pyplot as plt


def derivadabis(u,g,h,metodo):
    if metodo == 'centrada':
        der=(g(u+h)-g(u-h))/(2*h)
    else: 
        der((g(u+h)-g(u))/h)
    return der

def func1(t):
    return(t**2)

def func2(t):
    return t**2 - 1

def func3(t):
    return (mt.sin(t))-t

def norma(x):
    return (mt.sqrt(x[0]**2+x[1]**2))
norma(vec)

#Clase 6: BILLAR ELIPTICO

#Función elíptica
def elip_func(a,b,x):
    return x[0]**2/a**2+x[1]**2/b**2

def recta(p,t,v):
    vt=tuple(t*i for i in v)
    x1=p[0]+vt[0]
    y1=p[1]+vt[1]
    return(x1,y1)

def comp(t):
    return(elip_func(a1,b1,recta(pos,t,vec)))
comp(3)

#Metodo de newton
def metNewton(xi,f,kmax):
    k=0
    while k<kmax:
        if derivadabis(xi,f,0.001,'centrada')!=0:
            xf=xi-f(xi)/derivadabis(xi,f,0.001,'centrada')
            xi=xf
            k=k+1
        else:
            return xf, k
    return xf, k

#Pruebo si funciona con alguna funcion
m,n=metNewton(3,func1,100)
func1(m) #da un numero muy cercano a 0


#Defino mis condiciones
pos=(1,1)
vec=(3/5,4/5)

a1=mt.sqrt(2)
b1=mt.sqrt(2)

#Hago cuenta por cuenta para ver si usando el metodo me da igual. 
#r1=recta(pos,5,vec)
#elip_func(a1,b1,r1)
#g=comp(5) #me dan iguales asi que esta bien la composicion.

#Calculo mi t*
t_estrella, reps = metNewton(8,comp,200)

#Tengo que buscar el punto de impacto evaluando t* en la recta. 
punto_impacto=recta(pos,t_estrella,vec)

#Verifico evaluando en la elipse, se tiene que anular. 
elip_func(a1,b1,punto_impacto) #me da cercano a cero 

#Hallar el vector tangente
def elip_func2(a,b,x):
